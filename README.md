# combie-redis-with-floodlight
在SDN架构下，交换机是根据流表来对数据转发的，如果交换机收到的数据包在流表中不能匹配，就会产生Packet-in消息来询问控制器，控制器根据自己已存储好的网络拓扑信息来产生相应的流表下发给交换机，交换机根据流表来对数据包进行转发，主流的SDN控制器都有相应的模块来根据自己的网络视图以及交换机的Packet-in消息来产生相应的流表，比如opendaylight用l2-switch模块产生相应的流表，并通过openflowplugin将流表下发给交换机，floodlight则是通过routing模块根据自己当前存储的网络视图生成相应的转发路径然后产生flow mod消息通过forwarding模块下发给相应的交换机。
但是，如果网络拓扑在没有任何改变的情况下，相同的源节点和目的节点之间的转发路径是一样的，对应的流表也是一样的，但是当这些流表在交换机上过期以后，交换机会产生重复的请求来询问控制器，控制器会进行重复的处理并下发流表，这会造成一些资源的浪费。实际上，在这个过程中，交换机即是客户端，而控制器即是服务端，在服务器后台开发时，面对高并发的问题，经常会使用各种粒度的缓存来缓解服务器的压力，提高运行效率，redis作为一个高性能的key-value数据库，经常用于后台开发来实现页面缓存、URL缓存以及访问数据库时候的对象缓存。那么redis能不能用于控制器上来实现对流表的缓存呢？通过redis缓存这些流表，避免控制器重复处理交换机的重复的流表请求，能大大提高控制器的工作效率。本文项目在floodlight控制器上集成redis来实现对流表信息的缓存。
